= Devfiles

A Devfile is a YAML-based configuration file used to describe and manage development environments. Originally introduced as part of the Eclipse Che and OpenShift development ecosystems, it has since gained broader adoption. A Devfile defines the dependencies, tools, and environments required for a developer to build, test, and run applications consistently across different platforms. It can be used in cloud-native development environments, especially in Kubernetes-based systems.

Key Components of a Devfile:
Projects: Lists the repositories that need to be cloned or initialized for the development environment.
Components: Defines various containers or plugins (like databases, runtimes) needed in the development workspace.
Commands: Specifies tasks or actions such as "build," "run," and "test" that can be executed within the environment.
Events: Allows automation of tasks at certain stages, such as before starting or after stopping a container.
Advantages of Using a Devfile:
Consistent Environments:

Developers can define all aspects of the development environment in one place. This ensures that environments are consistent across different machines or teams, reducing "it works on my machine" issues.
Cloud-Native Development:

Devfiles are designed to work seamlessly with cloud-native environments like Kubernetes or OpenShift, enabling rapid scaling, collaboration, and on-demand provisioning of development resources.
Portability:

Since the Devfile is declarative and uses standard components, it can be easily ported across different development setups and infrastructure, including cloud-based Integrated Development Environments (IDEs) like Eclipse Che.
Automation:

By defining commands and events in the Devfile, repetitive tasks such as builds, tests, and deployments can be automated, improving productivity and reducing manual errors.
Simplifies Onboarding:

New developers can get up and running quickly by simply cloning the Devfile and spinning up the predefined environment, reducing the setup time for new projects or contributors.
Collaboration and Versioning:

Devfiles can be stored in source control along with the project’s code, making it easy to version, share, and collaborate on development environments in the same way as with code.
Support for Multiple Languages:

Devfiles are flexible and can be used with various programming languages, frameworks, and technologies, making them adaptable to a wide range of development projects.
Extensible and Customizable:

Devfiles can be extended and customized to suit specific development workflows by adding new components or adjusting commands, making them a powerful tool for developers with diverse needs.
In summary, a Devfile helps streamline development by providing a consistent, automated, and cloud-native approach to setting up and managing development environments. This makes it particularly beneficial for teams working on modern, distributed, and containerized applications.

Here’s an example of a Devfile in YAML format, defining a development environment for a simple Node.js application. This includes components like the application runtime, the project to be cloned, and commands to build, run, and test the app.

schemaVersion: 2.1.0

metadata:
  name: nodejs-sample-app
  version: 1.0.0
  description: Devfile for a sample Node.js application

projects:
  - name: nodejs-app
    source:
      type: git
      location: "https://github.com/some-repository/nodejs-app.git"
      branch: main

components:
  - name: nodejs
    container:
      image: "node:16"
      memoryLimit: 512Mi
      mountSources: true
      command: ["npm"]
      args: ["start"]
      volumeMounts:
        - name: node-modules
          path: "/projects/node_modules"
      endpoints:
        - name: "app"
          targetPort: 3000
          exposure: public
          protocol: http

  - name: postgres-db
    container:
      image: "postgres:13"
      memoryLimit: 512Mi
      env:
        - name: POSTGRES_USER
          value: user
        - name: POSTGRES_PASSWORD
          value: password
        - name: POSTGRES_DB
          value: devdb
      volumeMounts:
        - name: db-data
          path: "/var/lib/postgresql/data"

commands:
  - id: install
    exec:
      component: nodejs
      commandLine: "npm install"
      workingDir: /projects/nodejs-app
      group:
        kind: build
        isDefault: true

  - id: run
    exec:
      component: nodejs
      commandLine: "npm run dev"
      workingDir: /projects/nodejs-app
      group:
        kind: run
        isDefault: true

  - id: test
    exec:
      component: nodejs
      commandLine: "npm test"
      workingDir: /projects/nodejs-app
      group:
        kind: test
        isDefault: true

events:
  preStart:
    - install
  postStop:
    - id: cleanup
      exec:
        component: nodejs
        commandLine: "npm run clean"

volumes:
  - name: node-modules
    size: 1Gi
  - name: db-data
    size: 1Gi

Breakdown of the Example:
Metadata:

Contains basic information about the project like the name, version, and description.
Projects:

Specifies a project that will be cloned from a Git repository into the workspace (nodejs-app).
location: URL of the Git repository and the branch to be checked out.
Components:

Defines two containers:
Node.js container for running the application.
PostgreSQL database container for local development purposes.
Each container has a memory limit, environment variables (for the database), and volume mounts for persistence (node_modules for dependencies, db-data for PostgreSQL data).
Endpoints are also specified (exposing the app on port 3000).
Commands:

Install: Runs npm install to install dependencies when the environment is set up.
Run: Starts the Node.js app using npm run dev.
Test: Executes the test suite with npm test.
Commands are grouped into build, run, and test categories, allowing tools like Eclipse Che to present them appropriately in the UI.
Events:

PreStart event installs dependencies before the app starts.
PostStop event runs a cleanup task after the environment is stopped.
Volumes:

Persistent storage for node_modules and PostgreSQL data is provided using Kubernetes volumes.
Advantages of This Example:
Reproducibility: Any developer cloning this repository can instantly replicate the development environment, complete with the necessary tools and databases.
Automation: Key actions like building, running, and testing are automated through predefined commands.
Isolation: Containers ensure that the Node.js application and PostgreSQL database are isolated, consistent, and easy to manage.

Devfile for a Quarkus back-end application. Quarkus is a Kubernetes-native Java stack tailored for OpenJDK HotSpot and GraalVM. This devfile sets up a development environment that builds, runs, and tests the Quarkus application in a containerized setup.

schemaVersion: 2.1.0

metadata:
  name: quarkus-backend-app
  version: 1.0.0
  description: Devfile for a Quarkus back-end application

projects:
  - name: quarkus-app
    source:
      type: git
      location: "https://github.com/some-repository/quarkus-app.git"
      branch: main

components:
  - name: quarkus
    container:
      image: "quay.io/quarkus/ubi-quarkus-mandrel:22.3-java17"
      memoryLimit: 1Gi
      mountSources: true
      endpoints:
        - name: "quarkus"
          targetPort: 8080
          exposure: public
          protocol: http
      env:
        - name: QUARKUS_LAUNCH_DEVMODE
          value: "true"

  - name: postgres-db
    container:
      image: "postgres:13"
      memoryLimit: 512Mi
      env:
        - name: POSTGRES_USER
          value: user
        - name: POSTGRES_PASSWORD
          value: password
        - name: POSTGRES_DB
          value: quarkusdb
      volumeMounts:
        - name: db-data
          path: "/var/lib/postgresql/data"

commands:
  - id: build
    exec:
      component: quarkus
      commandLine: "./mvnw clean install"
      workingDir: /projects/quarkus-app
      group:
        kind: build
        isDefault: true

  - id: run
    exec:
      component: quarkus
      commandLine: "./mvnw compile quarkus:dev"
      workingDir: /projects/quarkus-app
      group:
        kind: run
        isDefault: true

  - id: test
    exec:
      component: quarkus
      commandLine: "./mvnw test"
      workingDir: /projects/quarkus-app
      group:
        kind: test
        isDefault: true

events:
  preStart:
    - build

volumes:
  - name: db-data
    size: 1Gi

Breakdown of This Devfile:
Metadata:

Defines the project’s name (quarkus-backend-app), version (1.0.0), and description.
Projects:

Specifies the Quarkus application project to be cloned from a Git repository.
Components:

Defines two main containers:
Quarkus container:
Uses the Mandrel-based image for Quarkus with Java 17 (this is a native-image enabled build image for Quarkus).
Limits the memory usage to 1Gi.
Exposes port 8080 where the Quarkus application will run.
An environment variable QUARKUS_LAUNCH_DEVMODE is set to true for enabling live reload (developer mode).
PostgreSQL database container:
Uses the postgres:13 image.
Defines environment variables for the database user, password, and database name.
Mounts a persistent volume (db-data) to persist the PostgreSQL data across container restarts.
Commands:

Build: Uses ./mvnw clean install to build the Quarkus application and its dependencies.
Run: Runs the Quarkus application in development mode using ./mvnw compile quarkus:dev (which enables live reload, debugging, and fast feedback loops).
Test: Executes the test suite with ./mvnw test.
These commands are tied to the Quarkus container, and they are grouped under build, run, and test respectively.
Events:

PreStart: Ensures the application is built before starting the development environment.
Volumes:

Defines a db-data volume for persisting the PostgreSQL database across environment restarts. It prevents the loss of data during container lifecycle changes.
Advantages for Quarkus Application:
Live Reload in Dev Mode: With quarkus:dev, developers can benefit from Quarkus’s live reload feature, speeding up the development cycle by avoiding manual restarts.
Database Integration: The PostgreSQL container ensures that the Quarkus application has a dedicated database, making it ideal for backend development.
Automation of Build/Run/Testing: The commands automate common tasks like building, running, and testing the Quarkus application.
Isolation: Each component (Quarkus runtime and database) is containerized, ensuring a clean and consistent environment across development setups.
This configuration enables developers to quickly set up a consistent and repeatable environment for Quarkus backend development, complete with database support and automated workflows.

== Objectives

* foo
* bar

