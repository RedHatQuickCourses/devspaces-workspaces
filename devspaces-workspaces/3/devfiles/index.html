<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Devfiles :: Creating and Customizing Workspaces in Red Hat OpenShift DevSpaces</title>
    <link rel="prev" href="../workspaces/ides.html">
    <link rel="next" href="create.html">
    <meta name="generator" content="Antora 3.1.3">
    <link rel="stylesheet" href="../../../_/css/site.css">
    <script>var uiRootPath = '../../../_'</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="https://www.redhat.com" target="_blank"><img src="../../../_/img/redhat-logo.png" height="40px" alt="Red Hat"></a>
      <a class="navbar-item" style="font-size: 24px; color: white" href="../../..">Creating and Customizing Workspaces in Red Hat OpenShift DevSpaces</a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="https://github.com/RedHatQuickCourses/devspaces-workspaces/issues" target="_blank">Report Issues</a>
      </div>
    </div>
  </nav>
</header><div class="body">
<div class="nav-container" data-component="devspaces-workspaces" data-version="3">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../index.html">Creating and Customizing Workspaces in Red Hat OpenShift DevSpaces</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../index.html">Home</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../workspaces/index.html">Workspaces</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../workspaces/create.html">Creating Workspaces</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../workspaces/udi.html">Universal Developer Image</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../workspaces/dashboard.html">Dev Spaces Dashboard</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../workspaces/custom.html">Samples Dashboard</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../workspaces/kubedock.html">Kubedock</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../workspaces/ides.html">Multiple IDEs in Dev Spaces</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item is-current-page" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="index.html">Devfiles</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="create.html">Creating a Devfile</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="registry.html">Devfile Registry</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Creating and Customizing Workspaces in Red Hat OpenShift DevSpaces</span>
    <span class="version">3</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <a class="title" href="../index.html">Creating and Customizing Workspaces in Red Hat OpenShift DevSpaces</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../index.html">3</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../index.html">Creating and Customizing Workspaces in Red Hat OpenShift DevSpaces</a></li>
    <li><a href="index.html">Devfiles</a></li>
  </ul>
</nav>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Devfiles</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>A Devfile is a YAML-based configuration file used to describe and manage development environments. Originally introduced as part of the Eclipse Che and OpenShift development ecosystems, it has since gained broader adoption. A Devfile defines the dependencies, tools, and environments required for a developer to build, test, and run applications consistently across different platforms. It can be used in cloud-native development environments, especially in Kubernetes-based systems.</p>
</div>
<div class="paragraph">
<p>Key Components of a Devfile:
Projects: Lists the repositories that need to be cloned or initialized for the development environment.
Components: Defines various containers or plugins (like databases, runtimes) needed in the development workspace.
Commands: Specifies tasks or actions such as "build," "run," and "test" that can be executed within the environment.
Events: Allows automation of tasks at certain stages, such as before starting or after stopping a container.
Advantages of Using a Devfile:
Consistent Environments:</p>
</div>
<div class="paragraph">
<p>Developers can define all aspects of the development environment in one place. This ensures that environments are consistent across different machines or teams, reducing "it works on my machine" issues.
Cloud-Native Development:</p>
</div>
<div class="paragraph">
<p>Devfiles are designed to work seamlessly with cloud-native environments like Kubernetes or OpenShift, enabling rapid scaling, collaboration, and on-demand provisioning of development resources.
Portability:</p>
</div>
<div class="paragraph">
<p>Since the Devfile is declarative and uses standard components, it can be easily ported across different development setups and infrastructure, including cloud-based Integrated Development Environments (IDEs) like Eclipse Che.
Automation:</p>
</div>
<div class="paragraph">
<p>By defining commands and events in the Devfile, repetitive tasks such as builds, tests, and deployments can be automated, improving productivity and reducing manual errors.
Simplifies Onboarding:</p>
</div>
<div class="paragraph">
<p>New developers can get up and running quickly by simply cloning the Devfile and spinning up the predefined environment, reducing the setup time for new projects or contributors.
Collaboration and Versioning:</p>
</div>
<div class="paragraph">
<p>Devfiles can be stored in source control along with the project’s code, making it easy to version, share, and collaborate on development environments in the same way as with code.
Support for Multiple Languages:</p>
</div>
<div class="paragraph">
<p>Devfiles are flexible and can be used with various programming languages, frameworks, and technologies, making them adaptable to a wide range of development projects.
Extensible and Customizable:</p>
</div>
<div class="paragraph">
<p>Devfiles can be extended and customized to suit specific development workflows by adding new components or adjusting commands, making them a powerful tool for developers with diverse needs.
In summary, a Devfile helps streamline development by providing a consistent, automated, and cloud-native approach to setting up and managing development environments. This makes it particularly beneficial for teams working on modern, distributed, and containerized applications.</p>
</div>
<div class="paragraph">
<p>Here’s an example of a Devfile in YAML format, defining a development environment for a simple Node.js application. This includes components like the application runtime, the project to be cloned, and commands to build, run, and test the app.</p>
</div>
<div class="paragraph">
<p>schemaVersion: 2.1.0</p>
</div>
<div class="paragraph">
<p>metadata:
  name: nodejs-sample-app
  version: 1.0.0
  description: Devfile for a sample Node.js application</p>
</div>
<div class="paragraph">
<p>projects:
  - name: nodejs-app
    source:
      type: git
      location: "https://github.com/some-repository/nodejs-app.git"
      branch: main</p>
</div>
<div class="paragraph">
<p>components:
  - name: nodejs
    container:
      image: "node:16"
      memoryLimit: 512Mi
      mountSources: true
      command: ["npm"]
      args: ["start"]
      volumeMounts:
        - name: node-modules
          path: "/projects/node_modules"
      endpoints:
        - name: "app"
          targetPort: 3000
          exposure: public
          protocol: http</p>
</div>
<div class="ulist">
<ul>
<li>
<p>name: postgres-db
container:
  image: "postgres:13"
  memoryLimit: 512Mi
  env:</p>
</li>
<li>
<p>name: POSTGRES_USER
value: user</p>
</li>
<li>
<p>name: POSTGRES_PASSWORD
value: password</p>
</li>
<li>
<p>name: POSTGRES_DB
    value: devdb
volumeMounts:</p>
</li>
<li>
<p>name: db-data
path: "/var/lib/postgresql/data"</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>commands:
  - id: install
    exec:
      component: nodejs
      commandLine: "npm install"
      workingDir: /projects/nodejs-app
      group:
        kind: build
        isDefault: true</p>
</div>
<div class="ulist">
<ul>
<li>
<p>id: run
exec:
  component: nodejs
  commandLine: "npm run dev"
  workingDir: /projects/nodejs-app
  group:
    kind: run
    isDefault: true</p>
</li>
<li>
<p>id: test
exec:
  component: nodejs
  commandLine: "npm test"
  workingDir: /projects/nodejs-app
  group:
    kind: test
    isDefault: true</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>events:
  preStart:
    - install
  postStop:
    - id: cleanup
      exec:
        component: nodejs
        commandLine: "npm run clean"</p>
</div>
<div class="paragraph">
<p>volumes:
  - name: node-modules
    size: 1Gi
  - name: db-data
    size: 1Gi</p>
</div>
<div class="paragraph">
<p>Breakdown of the Example:
Metadata:</p>
</div>
<div class="paragraph">
<p>Contains basic information about the project like the name, version, and description.
Projects:</p>
</div>
<div class="paragraph">
<p>Specifies a project that will be cloned from a Git repository into the workspace (nodejs-app).
location: URL of the Git repository and the branch to be checked out.
Components:</p>
</div>
<div class="paragraph">
<p>Defines two containers:
Node.js container for running the application.
PostgreSQL database container for local development purposes.
Each container has a memory limit, environment variables (for the database), and volume mounts for persistence (node_modules for dependencies, db-data for PostgreSQL data).
Endpoints are also specified (exposing the app on port 3000).
Commands:</p>
</div>
<div class="paragraph">
<p>Install: Runs npm install to install dependencies when the environment is set up.
Run: Starts the Node.js app using npm run dev.
Test: Executes the test suite with npm test.
Commands are grouped into build, run, and test categories, allowing tools like Eclipse Che to present them appropriately in the UI.
Events:</p>
</div>
<div class="paragraph">
<p>PreStart event installs dependencies before the app starts.
PostStop event runs a cleanup task after the environment is stopped.
Volumes:</p>
</div>
<div class="paragraph">
<p>Persistent storage for node_modules and PostgreSQL data is provided using Kubernetes volumes.
Advantages of This Example:
Reproducibility: Any developer cloning this repository can instantly replicate the development environment, complete with the necessary tools and databases.
Automation: Key actions like building, running, and testing are automated through predefined commands.
Isolation: Containers ensure that the Node.js application and PostgreSQL database are isolated, consistent, and easy to manage.</p>
</div>
<div class="paragraph">
<p>Devfile for a Quarkus back-end application. Quarkus is a Kubernetes-native Java stack tailored for OpenJDK HotSpot and GraalVM. This devfile sets up a development environment that builds, runs, and tests the Quarkus application in a containerized setup.</p>
</div>
<div class="paragraph">
<p>schemaVersion: 2.1.0</p>
</div>
<div class="paragraph">
<p>metadata:
  name: quarkus-backend-app
  version: 1.0.0
  description: Devfile for a Quarkus back-end application</p>
</div>
<div class="paragraph">
<p>projects:
  - name: quarkus-app
    source:
      type: git
      location: "https://github.com/some-repository/quarkus-app.git"
      branch: main</p>
</div>
<div class="paragraph">
<p>components:
  - name: quarkus
    container:
      image: "quay.io/quarkus/ubi-quarkus-mandrel:22.3-java17"
      memoryLimit: 1Gi
      mountSources: true
      endpoints:
        - name: "quarkus"
          targetPort: 8080
          exposure: public
          protocol: http
      env:
        - name: QUARKUS_LAUNCH_DEVMODE
          value: "true"</p>
</div>
<div class="ulist">
<ul>
<li>
<p>name: postgres-db
container:
  image: "postgres:13"
  memoryLimit: 512Mi
  env:</p>
</li>
<li>
<p>name: POSTGRES_USER
value: user</p>
</li>
<li>
<p>name: POSTGRES_PASSWORD
value: password</p>
</li>
<li>
<p>name: POSTGRES_DB
    value: quarkusdb
volumeMounts:</p>
</li>
<li>
<p>name: db-data
path: "/var/lib/postgresql/data"</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>commands:
  - id: build
    exec:
      component: quarkus
      commandLine: "./mvnw clean install"
      workingDir: /projects/quarkus-app
      group:
        kind: build
        isDefault: true</p>
</div>
<div class="ulist">
<ul>
<li>
<p>id: run
exec:
  component: quarkus
  commandLine: "./mvnw compile quarkus:dev"
  workingDir: /projects/quarkus-app
  group:
    kind: run
    isDefault: true</p>
</li>
<li>
<p>id: test
exec:
  component: quarkus
  commandLine: "./mvnw test"
  workingDir: /projects/quarkus-app
  group:
    kind: test
    isDefault: true</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>events:
  preStart:
    - build</p>
</div>
<div class="paragraph">
<p>volumes:
  - name: db-data
    size: 1Gi</p>
</div>
<div class="paragraph">
<p>Breakdown of This Devfile:
Metadata:</p>
</div>
<div class="paragraph">
<p>Defines the project’s name (quarkus-backend-app), version (1.0.0), and description.
Projects:</p>
</div>
<div class="paragraph">
<p>Specifies the Quarkus application project to be cloned from a Git repository.
Components:</p>
</div>
<div class="paragraph">
<p>Defines two main containers:
Quarkus container:
Uses the Mandrel-based image for Quarkus with Java 17 (this is a native-image enabled build image for Quarkus).
Limits the memory usage to 1Gi.
Exposes port 8080 where the Quarkus application will run.
An environment variable QUARKUS_LAUNCH_DEVMODE is set to true for enabling live reload (developer mode).
PostgreSQL database container:
Uses the postgres:13 image.
Defines environment variables for the database user, password, and database name.
Mounts a persistent volume (db-data) to persist the PostgreSQL data across container restarts.
Commands:</p>
</div>
<div class="paragraph">
<p>Build: Uses ./mvnw clean install to build the Quarkus application and its dependencies.
Run: Runs the Quarkus application in development mode using ./mvnw compile quarkus:dev (which enables live reload, debugging, and fast feedback loops).
Test: Executes the test suite with ./mvnw test.
These commands are tied to the Quarkus container, and they are grouped under build, run, and test respectively.
Events:</p>
</div>
<div class="paragraph">
<p>PreStart: Ensures the application is built before starting the development environment.
Volumes:</p>
</div>
<div class="paragraph">
<p>Defines a db-data volume for persisting the PostgreSQL database across environment restarts. It prevents the loss of data during container lifecycle changes.
Advantages for Quarkus Application:
Live Reload in Dev Mode: With quarkus:dev, developers can benefit from Quarkus’s live reload feature, speeding up the development cycle by avoiding manual restarts.
Database Integration: The PostgreSQL container ensures that the Quarkus application has a dedicated database, making it ideal for backend development.
Automation of Build/Run/Testing: The commands automate common tasks like building, running, and testing the Quarkus application.
Isolation: Each component (Quarkus runtime and database) is containerized, ensuring a clean and consistent environment across development setups.
This configuration enables developers to quickly set up a consistent and repeatable environment for Quarkus backend development, complete with database support and automated workflows.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_objectives"><a class="anchor" href="#_objectives"></a>Objectives</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>foo</p>
</li>
<li>
<p>bar</p>
</li>
</ul>
</div>
</div>
</div>
<nav class="pagination">
  <span class="prev"><a href="../workspaces/ides.html">Multiple IDEs in Dev Spaces</a></span>
  <span class="next"><a href="create.html">Creating a Devfile</a></span>
</nav>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <img src="../../../_/img/rhl-logo-red.png" height="40px" alt="Red Hat"  href="https://redhat.com" >
</footer><script id="site-script" src="../../../_/js/site.js" data-ui-root-path="../../../_"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
  </body>
</html>
